Question:
Design a cache structure which has the fixed size K. It supports two operations:
1. set(key, value): insert the value into the cache
2. get(key): return the value by the key

Requirement:
1. set() and get() has O(1)
2. As long as set() or get() happens to the key, assume the record of the key is the mostly often used
3. when the size be more than K, remove the leastly often unused record, that is oldest key whose set/get happens

Example:
Assume the instance of the cache with size 3, then happens before the operations:
1. cache.set("A", 1). the mostly often used record is ("A", 1)
2. cache.set("B", 2). the mostly often used record is ("B",2), ("A", 1) becomes the leastly often used
3. cache.set("C", 3). the mostly often used record is ("C",2), ("A", 1) stays the leastly often used
4. cache.get("A"). the mostly often used record is ("A", 1), ("B", 2) becomes the leastly often used
5. cache.set("D", 4). size becomes more than 3, so remote the least often used record ("B", 2), add the \
record ("D", 4) as the mostly often used record, and ("C", 2) becomes the leastly often used record

Answer:
The cache structure can be implemented with a DQueue and a hash table. Firstly implement a basic DQueue with Node:
public class Node<V> {
  public V value;
  public Node<V> last;
  public Node<V> next;
  
  public Node(V value) {
    this.value = value;  
  }
}

Based on the Node, implement a double direction linked List structure NodeDoubleLinkedList, in the structure, the Node with lowest \
priority is head, the Node with highest priority is tail. This structure has three operations:
1. Add a Node, add it to the tail
2. Can move any Node to the tail
3. Remove head and return the value
public class NodeDoubleLinkedList<V> {
  private Node<V> head;
  private Node<V> tail;
  
  public void addNode(Node<V> newNode) {
    if(newNode == null) {
      return;
    }
    if(this.head ==null) {
      this.head = newNode;
      this.tail = newNode;
    }else{
      this.tail.next = newNode;
      newNode.last = this.tail;
      this.tail = newNode;
    }    
  }
  
  public void moveNodeToTail(Node<V> node){
    if(this.tail == null){
      return;
    }
    if(this.head == node){
      this.head = node.next;
      this.head.last = null;
    }else{
      node.last.next = node.next;
      node.next.last = node.last;
    }
    node.last = this.tail;
    node.next =  null;
    this.tail.next = node;
    this.tail =  node;
  }
  
  public Node<V> removeHead(){
    if(this.head = null){
      return null
    }
    Node<V> res  = this.head;
    if(this.head == this.tail) {
      this.head = null;
      this.tail = null;
    } else {
      this.head = res.next;
      res.next = null;
      this.head.last = null;
    }
    return res;
  }
}

Lastly implement the cache structure using the NodeDoubleLinkedList to sort based on mostly often used.
To 
public class MyCache<K,V>{
  private HashMap<K, Node<V>> keyNodeMap;
  private HashMap<Node<V>, K> nodeKeyMap;
  
  private NodeDoubleLinkedList<V> nodeList;
  private int capacity;
  
  public MyCache(int capacity) {
    if(capacity < 1){
      throw new RuntimeException("should be at least 0");
    }
    this.keyNodeMap = new HashMap<>();
    this.nodeKeyMap = new HashMap<>();
    this.nodeList = new NodeDoubleLinkedList();
    this.capacity = capacity;
  }
  
  public V get(K key) {
    if(this.keyNodeMap.containsKey(key){
      Node<V> res = this.keyNodeMap.get(key);
      this.nodeList.moveNodeToTail(res);
      return res.value;
    }
    return null;
  }
  
  public void set(K key, V value){
    if(this.keyNodeMap.containsKey(key)){
      Node<V> node = this.keyNodeMap.get(key);
      node.value = value;
      this.nodeList.moveNodeToTail(node);
    }else{
      Node<V> newNode = new Node<V>(value);
      this.keyNodeMap.put(key, newNode);
      this.nodeKeyMap.put(newNode, key);
      this.nodeList.addNode(newNode);
      if(this.keyNodeMap.size() == this.capacity + 1) {
        this.removeMostUnusedCache();
      }
    }  
  }
  
  private void removeMostUnusedCache(){
    Node<V> removeNode = this.nodeList.removeHead();
    K removeKey = this.nodeKeyMap.get(removeNode);
    this.nodeKeyMap.remove(removeNode);
    this.keyNodeMap.remove(removeKey);
  }
}
  
  
    










